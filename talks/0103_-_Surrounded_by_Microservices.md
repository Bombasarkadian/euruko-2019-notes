[üëà Back to all talks üëà](../README.md)

------

# Surrounded by Microservices

## Damir Svrtan [@DamirSvrtan](https://twitter.com/DamirSvrtan)

Netfilx started as a company that gave people opportunity to experience ad-free experience and access to many movies and tv shows. Recently Netflix started creating their own series. It turns out that this business is still kind of stuck in a previous era. Netflix creates apps that help them reduce traction and cover every part of production process.

Netflix started as a monolith with Rails application. It has since split into many specialized services. Ruby on Rails is still a framework of choice for building new tools there. Since all apps and databases are distributed, there is some different approach required.

![0103-data-sources](media/0103-data-sources.jpg)

We need an architecture that separates busines logic from implementation details. It‚Äôs called a hexagonal architecture. It allows splitting busines logic from all surrounding protocols and impementations. It‚Äôs built around Entities (such as a movie, a production etc). They don‚Äôt actually care about where they‚Äôre stored - it‚Äôs ActiveRecord‚Äôs job. It uses many Data Sources to handle this. Data Source may be an SQL database, JSON file or just any place that can store data.

![0103-hexagonal](media/0103-hexagonal.jpg)

Then we have Interactions. They are classes that explicitly state what they do and how the handle business logic. How do we build all this?

For Entities we can use dry-rb and their stuctures. For Repositories a custom DSL layer is used. It helps route requests into responsible Data Sources that all implement the same interface. Implementation details never leave Data Source. It allows changing Data Source at will without having to do any changes in Repositories or Business Layer.

For Interactions there is an Interactor gem. Interactor gets a Repository throurh Dependency Injection, so we never mix Business Logic with Persistence. This is not exactly how Rails does things, and actually Hanami will be better suited for this. But Rails still has a lot of useful gems (such as counters culture) that make it more viabla choice.

![0103-dependency-injection](media/0103-dependency-injection.jpg)

How do we crate a data source that is dependent on extrenal data? One way would be to create an API client for each required integration. But it‚Äôs better to have autogenerated clients. This can be achieved by having each API follow some documentation standard that allows generating clients (such as Swagger).

Whe your only data source is the database there is a single point of failure. But with many data sources there are many places that can fail. Networks are unreliable and we must be prepared for an outage. This can be done by doing proper graceful failure and having proper logging in place.

In order on to get overwhelmed by your services it‚Äôs important to have metrics in place. Of course you can‚Äôt proceed without Error tracking. But we don‚Äôt want to be overwhelmed by all kinds of errors - we only want the ones that are actionable and be can do something about them. We don‚Äôt want to experience ‚ÄúAlarm Fatigue‚Äù - having too many alerts will lead to people ignoring them. It‚Äôs a good idea to have some kind of a threshold setup.

![0103-alarm-fatigue](media/0103-alarm-fatigue.jpg)

But does it scale well? In the end we add a lot of network requests to our applications. Before we answer this we should try to find a sweet spot in consistency--availability spectrum. Shops sucha s Apple or Amazon will always focus on availability, because it‚Äôs important for them to ell stuff. But in our case we may prefer to have consistent data over having better availability. With microservices we can delay having to make big decisions until we actually need them. It‚Äôs easy to switch databases and technologies, because or application is not tightly coupled.

Then there are tests. Tests must be reliable and fast - we don‚Äôt want to have to run them only on CI server. Usually we test Rails applications by hitting the database, because the database is coupled into implementation. With Dependency Injection it‚Äôs easy to test Interactors without heving to use database - we can supply it with any Data Soruce we want. But it‚Äôs only for Unit Tests, what about Integrationspecs? There are two layers. FIrst one is checking if we‚Äôve properly integrated with other services. Second one is basically running requests with external services calls stubbed out.

![0103-delay-decisions](media/0103-delay-decisions.jpg)